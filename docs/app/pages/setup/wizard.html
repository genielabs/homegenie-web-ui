<html><head>    <style>[data-ui-view]:not([data-ui-include]):not([data-ui-load]) { display: none; }</style>
</head><body><div data-ui-load="@lib/controllers/view_pager" data-o-paging="true" layout="row stretch-stretch">

    <div class="page" layout="column center-center">
        <button class="nav-close" data-ui-field="btn-close" layout="row center-center">
            <span class="material-icons">close</span>
        </button>
        <div>
            <h1>Settings</h1>
        </div>
        <div>
            <div class="text-caption text-light text-bold">Server address</div>
            <input type="text" placeholder="host:port" data-ui-field="server-address">
            <button data-ui-field="btn-connect">Connect</button>
        </div>
    </div>
    <div class="page scrollable" data-ui-load="@lib/controllers/list_view" data-ui-context="module-list" onscroll="zuix.componentize(this)" layout="rows stretch-stretch"><!--no-view--></div>
    <div class="page" layout="column center-center">
        page 3
    </div>
    <div class="page" layout="column center-center">
        page 4
    </div>
    <div class="page" layout="column center-center">
        page 5
    </div>

</div>
<!-- zUIx inline resource resourceBundle -->
<script>zuix.bundle([
  {
    "componentId": "https://zuixjs.github.io/zkit/lib/controllers/view_pager",
    "controller": "/**\n * zUIx - ViewPager Component\n *\n * @version 1.0.6 (2018-08-24)\n * @author Gene\n *\n * @version 1.0.5 (2018-08-21)\n * @author Gene\n *\n * @version 1.0.4 (2018-06-29)\n * @author Gene\n *\n * @version 1.0.3 (2018-06-26)\n * @author Gene\n *\n * @version 1.0.1 (2018-02-12)\n * @author Gene\n *\n */\n\n'use strict';\n\nzuix.controller(function(cp) {\n    const DEFAULT_PAGE_TRANSITION = {duration: 0.3, easing: 'ease'};\n    const BOUNDARY_HIT_EASING = 'cubic-bezier(0.0,0.1,0.35,1.1)';\n    const DECELERATE_SCROLL_EASING = 'cubic-bezier(0.0,0.1,0.35,1.0)';\n    const LAYOUT_HORIZONTAL = 'horizontal';\n    const LAYOUT_VERTICAL = 'vertical';\n    const SLIDE_DIRECTION_FORWARD = 1;\n    const SLIDE_DIRECTION_BACKWARD = -1;\n    // state vars\n    let currentPage = -1;\n    let oldPage = 0;\n    let slideTimeout = null;\n    let slideIntervalMs = 3000;\n    let slideDirection = SLIDE_DIRECTION_FORWARD;\n    let updateLayoutTimeout = null;\n    let inputCaptured = false;\n    // options\n    let layoutType = LAYOUT_HORIZONTAL;\n    let enableAutoSlide = false;\n    let enablePaging = false;\n    let holdTouch = false;\n    let passiveMode = true;\n    let startGap = 0;\n    let hideOffViewElements = false;\n    // status\n    let isDragging = false;\n    let wasVisible = false;\n    let isLazyContainer = false;\n    let isFlying = false;\n    let actualViewSize = {\n        width: 0,\n        height: 0\n    };\n    // timers\n    let componentizeInterval = null;\n    let componentizeTimeout = null;\n    /** @typedef {ZxQuery} */\n    let pageList = null;\n    // Create a mutation observer instance to watch for child add/remove\n    const domObserver = new MutationObserver(function(a, b) {\n        // update child list and re-layout\n        pageList = cp.view().children();\n        updateLayout();\n    });\n\n    cp.init = function() {\n        let options = cp.options();\n        let view = cp.view();\n        options.html = false;\n        options.css = false;\n        enablePaging = (options.enablePaging === true || (view.attr('data-o-paging') === 'true'));\n        enableAutoSlide = (options.autoSlide === true || (view.attr('data-o-slide') === 'true'));\n        passiveMode = (options.passive !== false && (view.attr('data-o-passive') !== 'false'));\n        holdTouch = (options.holdTouch === true || (view.attr('data-o-hold') === 'true'));\n        startGap = (options.startGap || view.attr('data-o-startgap'));\n        if (options.verticalLayout === true || (view.attr('data-o-layout') === LAYOUT_VERTICAL)) {\n            layoutType = LAYOUT_VERTICAL;\n        }\n        if (options.slideInterval != null) {\n            slideIntervalMs = options.slideInterval;\n        } else if (view.attr('data-o-slide-interval') != null) {\n            slideIntervalMs = parseInt(view.attr('data-o-slide-interval'));\n        }\n        hideOffViewElements = (options.autohide === true || (view.attr('data-o-autohide') === 'true'));\n    };\n\n    cp.create = function() {\n        // enable absolute positioning for items in this view\n        const view = cp.view().css({\n            'position': 'relative',\n            'overflow': 'hidden'\n        });\n        // get child items (pages)\n        pageList = view.children();\n        // loading of images could change elements size, so layout update might be required\n        view.find('img').each(function(i, el) {\n            this.one('load', updateLayout);\n        });\n        // re-arrange view on layout changes\n        zuix.$(window)\n            .on('resize', function() {\n                layoutElements(true);\n            }).on('orientationchange', function() {\n            layoutElements(true);\n        });\n        // Options for the observer (which mutations to observe)\n        // Register DOM mutation observer callback\n        domObserver.observe(view.get(), {\n            attributes: false,\n            childList: true,\n            subtree: true,\n            characterData: false\n        });\n        updateLayout();\n        // Set starting page\n        setPage(0);\n        let tapTimeout = null;\n        // gestures handling - load gesture_helper controller\n        zuix.load('@lib/controllers/gesture_helper', {\n            view: view,\n            passive: passiveMode,\n            startGap: startGap,\n            on: {\n                'gesture:touch': function(e, tp) {\n                    inputCaptured = false;\n                    stopAutoSlide();\n                    dragStart();\n                    if (holdTouch) tp.cancel();\n                },\n                'gesture:release': function(e, tp) {\n                    dragStop(tp);\n                    resetAutoSlide();\n                },\n                'gesture:tap': function(e, tp) {\n                    if (tapTimeout != null) {\n                        clearTimeout(tapTimeout);\n                    }\n                    tapTimeout = setTimeout(function() {\n                        handleTap(e, tp);\n                    }, 50);\n                },\n                'gesture:pan': handlePan,\n                'gesture:swipe': handleSwipe\n            },\n            ready: function() {\n                layoutElements(true);\n            }\n        });\n        // public component methods\n        cp.expose('page', function(number) {\n            if (number == null) {\n                return parseInt(currentPage);\n            } else setPage(number, DEFAULT_PAGE_TRANSITION);\n        }).expose('get', function(number) {\n            return pageList.eq(number);\n        }).expose('slide', function(activate) {\n            if (activate === true) {\n                resetAutoSlide();\n            } else stopAutoSlide();\n        }).expose('layout', function(mode) {\n            if (mode == null) {\n                return layoutType;\n            } else if (mode === LAYOUT_VERTICAL) {\n                layoutType = LAYOUT_VERTICAL;\n            } else layoutType = LAYOUT_HORIZONTAL;\n            updateLayout();\n        }).expose('refresh', function() {\n            layoutElements(true);\n        }).expose('next', next)\n            .expose('prev', prev)\n            .expose('last', last)\n            .expose('first', first);\n    };\n\n    cp.destroy = function() {\n        if (domObserver != null) {\n            domObserver.disconnect();\n        }\n    };\n\n    function updateLayout() {\n        if (updateLayoutTimeout != null) {\n            clearTimeout(updateLayoutTimeout);\n        }\n        updateLayoutTimeout = setTimeout(layoutElements, 250);\n    }\n    function layoutElements(force) {\n        if (!force && (isDragging || componentizeInterval != null)) {\n            updateLayout();\n            return;\n        }\n        // init elements\n        pageList.each(function(i, el) {\n            this.css({\n                'position': 'absolute',\n                'left': 0,\n                'top': 0\n            });\n        });\n        // measure\n        const viewSize = getSize(cp.view().get());\n        if (viewSize.width === 0 || viewSize.height === 0) {\n            if (viewSize.height === 0 && cp.view().position().visible) {\n                let maxHeight = 0;\n                // guess and set view_pager height\n                pageList.each(function(i, el) {\n                    let size = getSize(el);\n                    if (size.height > maxHeight) {\n                        maxHeight = size.height;\n                    }\n                });\n                if (viewSize.height < maxHeight) {\n                    cp.view().css('height', maxHeight + 'px');\n                }\n            }\n            // cannot measure view, try again later\n            updateLayout();\n            return;\n        }\n        actualViewSize = viewSize;\n        // position elements\n        let offset = 0;\n        let isLazy = false;\n        pageList.each(function(i, el) {\n            let size = getSize(el);\n            if (layoutType === LAYOUT_HORIZONTAL) {\n                let centerY = (viewSize.height-size.height)/2;\n                if (centerY < 0) centerY = 0; // TODO: centering with negative offset was not working\n                transition(this, DEFAULT_PAGE_TRANSITION);\n                position(this, offset, centerY);\n                offset += size.width;\n            } else {\n                let centerX = (viewSize.width-size.width)/2;\n                if (centerX < 0) centerX = 0; // TODO: centering with negative offset was not working\n                transition(this, DEFAULT_PAGE_TRANSITION);\n                position(this, centerX, offset);\n                offset += size.height;\n            }\n            if (this.attr('data-ui-lazyload') === 'true'\n                || this.find('[data-ui-lazyload=\"true\"]').length() > 0) {\n                isLazy = true;\n            }\n        });\n        isLazyContainer = isLazy;\n\n        // focus to current page\n        setPage(currentPage);\n        // start automatic slide\n        if (pageList.length() > 1) {\n            resetAutoSlide();\n        }\n    }\n\n    function next() {\n        let isLast = false;\n        let page = parseInt(currentPage)+1;\n        if (page >= pageList.length()) {\n            page = pageList.length()-1;\n            isLast = true;\n        }\n        setPage(page, DEFAULT_PAGE_TRANSITION);\n        return !isLast;\n    }\n    function prev() {\n        let isFirst = false;\n        let page = parseInt(currentPage)-1;\n        if (page < 0) {\n            page = 0;\n            isFirst = true;\n        }\n        setPage(page, DEFAULT_PAGE_TRANSITION);\n        return !isFirst;\n    }\n    function first() {\n        setPage(0, DEFAULT_PAGE_TRANSITION);\n    }\n    function last() {\n        setPage(pageList.length()-1, DEFAULT_PAGE_TRANSITION);\n    }\n\n    function slideNext() {\n        setPage(parseInt(currentPage) + slideDirection, DEFAULT_PAGE_TRANSITION);\n        resetAutoSlide();\n    }\n\n    function resetAutoSlide(timeout) {\n        stopAutoSlide();\n        if (enableAutoSlide === true) {\n            const visible = cp.view().position().visible;\n            if (visible) {\n                if (!wasVisible) {\n                    zuix.componentize(cp.view());\n                }\n                slideTimeout = setTimeout(slideNext, slideIntervalMs);\n            } else {\n                slideTimeout = setTimeout(resetAutoSlide, 500);\n            }\n            wasVisible = visible;\n        }\n    }\n    function stopAutoSlide() {\n        if (slideTimeout != null) {\n            clearTimeout(slideTimeout);\n        }\n    }\n\n    function getItemIndexAt(x, y) {\n        let focusedPage = 0;\n        pageList.each(function(i, el) {\n            let data = getData(this);\n            focusedPage = i;\n            const size = getSize(el);\n            const rect = {\n                x: data.position.x,\n                y: data.position.y,\n                w: size.width,\n                h: size.height\n            };\n            if ((layoutType === LAYOUT_HORIZONTAL && (rect.x > x || rect.x+rect.w > x))\n                || (layoutType === LAYOUT_VERTICAL && (rect.y > y || rect.y+rect.h > y))) {\n                return false;\n            }\n        });\n        return focusedPage;\n    }\n\n    function focusPageAt(tp, transition) {\n        let vp = cp.view().position();\n        let page = getItemIndexAt(tp.x-vp.x, tp.y-vp.y);\n        setPage(page, transition != null ? transition : DEFAULT_PAGE_TRANSITION);\n    }\n\n    function setPage(n, transition) {\n        oldPage = currentPage;\n        if (n < 0) {\n            slideDirection = SLIDE_DIRECTION_FORWARD;\n            n = 0;\n        } else if (n >= pageList.length()) {\n            slideDirection = SLIDE_DIRECTION_BACKWARD;\n            n = pageList.length() - 1;\n        } else if (n !== currentPage) {\n            slideDirection = (currentPage < n) ? SLIDE_DIRECTION_FORWARD : SLIDE_DIRECTION_BACKWARD;\n        }\n        currentPage = n;\n        if (currentPage != oldPage) {\n            pageList.eq(currentPage).css('z-index', 1);\n            if (oldPage !== -1) {\n                pageList.eq(oldPage).css('z-index', 0);\n            }\n            cp.trigger('page:change', {in: currentPage, out: oldPage});\n        }\n        const el = pageList.eq(n);\n        const data = getData(el);\n        const elSize = getSize(el.get());\n        const focusPoint = {\n            x: (actualViewSize.width - elSize.width) / 2 - data.position.x,\n            y: (actualViewSize.height - elSize.height) / 2 - data.position.y\n        };\n        flyTo(focusPoint, transition);\n        resetAutoSlide();\n    }\n\n    function flyTo(targetPoint, transition) {\n        const spec = getFrameSpec();\n        const firstData = getData(pageList.eq(0));\n        const lastPage = pageList.eq(pageList.length() - 1);\n        const lastData = getData(lastPage);\n\n        pageList.each(function(i, el) {\n            const data = getData(this);\n            const frameSpec = getFrameSpec();\n            data.dragStart = {\n                x: frameSpec.marginLeft + data.position.x,\n                y: frameSpec.marginTop + data.position.y\n            };\n        });\n\n        if (layoutType === LAYOUT_HORIZONTAL) {\n            let x = targetPoint.x;\n            if (firstData.position.x + targetPoint.x > 0) {\n                x = -firstData.position.x;\n            } else {\n                if (lastData.position.x + lastPage.get().offsetWidth + targetPoint.x < actualViewSize.width) {\n                    x = -spec.marginLeft*2 + actualViewSize.width - (lastData.position.x + lastPage.get().offsetWidth);\n                }\n            }\n            // check if boundary was adjusted and adjust flying duration accordingly\n            if (targetPoint.x-x !== 0 && transition != null) {\n                transition = {\n                    duration: transition.duration * (x / targetPoint.x),\n                    easing: BOUNDARY_HIT_EASING\n                };\n                if (!isFinite(transition.duration) || transition.duration < 0) {\n                    transition.duration = 0.2;\n                }\n            }\n            dragShift(x, 0, transition);\n        } else {\n            let y = targetPoint.y;\n            if (firstData.position.y + targetPoint.y > 0) {\n                y = -firstData.position.y;\n            } else {\n                if (lastData.position.y + lastPage.get().offsetHeight + targetPoint.y < actualViewSize.height) {\n                    y = -spec.marginTop*2 + actualViewSize.height - (lastData.position.y + lastPage.get().offsetHeight);\n                }\n            }\n            // check if boundary was adjusted and adjust flying duration accordingly\n            if (targetPoint.y-y !== 0 && transition != null) {\n                transition = {\n                    duration: transition.duration * (y / targetPoint.y),\n                    easing: BOUNDARY_HIT_EASING\n                };\n                if (!isFinite(transition.duration) || transition.duration < 0) {\n                    transition.duration = 0.2;\n                }\n            }\n            dragShift(0, y, transition);\n        }\n        isFlying = true;\n    }\n\n    function getSize(el) {\n        const rect = el.getBoundingClientRect();\n        const width = rect.width || el.offsetWidth;\n        const height = el.offsetHeight || rect.height;\n        return {width: width, height: height};\n    }\n\n    function getData(el) {\n        const data = el.get().data = el.get().data || {};\n        data.position = data.position || {x: 0, y: 0};\n        return data;\n    }\n\n    function componentizeStart() {\n        if (isLazyContainer) {\n            componentizeStop();\n            if (componentizeTimeout != null) {\n                clearTimeout(componentizeTimeout);\n            }\n            if (componentizeInterval != null) {\n                clearInterval(componentizeInterval);\n            }\n            componentizeInterval = setInterval(function() {\n                if (hideOffViewElements) {\n                    pageList.each(function(i, el) {\n                        // hide elements if not inside the view_pager\n                        const computed = window.getComputedStyle(el, null);\n                        const size = {\n                            width: parseFloat(computed.width.replace('px', '')),\n                            height: parseFloat(computed.height.replace('px', ''))\n                        };\n                        const x = parseFloat(computed.left.replace('px', ''));\n                        const y = parseFloat(computed.top.replace('px', ''));\n                        if (size.width > 0 && size.height > 0) {\n                            el = zuix.$(el);\n                            // check if element is inside the view_pager\n                            if (x + size.width < 0 || y + size.height < 0 || x > actualViewSize.width || y > actualViewSize.height) {\n                                if (el.visibility() !== 'hidden') {\n                                    el.visibility('hidden');\n                                }\n                            } else if (el.visibility() !== 'visible') {\n                                el.visibility('visible');\n                            }\n                        }\n                    });\n                }\n                zuix.componentize(cp.view());\n            }, 10);\n        }\n    }\n\n    function componentizeStop() {\n        if (isLazyContainer && componentizeTimeout == null) {\n            clearInterval(componentizeInterval);\n        }\n    }\n\n    function dragStart() {\n        isDragging = true;\n        isFlying = false;\n        pageList.each(function(i, el) {\n            const data = getData(this);\n            const frameSpec = getFrameSpec();\n            const computed = window.getComputedStyle(el, null);\n            data.position.x = parseFloat(computed.left.replace('px', ''));\n            data.position.y = parseFloat(computed.top.replace('px', ''));\n            this.css('left', data.position.x+'px');\n            this.css('top', data.position.y+'px');\n            data.dragStart = {x: frameSpec.marginLeft+data.position.x, y: frameSpec.marginTop+data.position.y};\n        });\n    }\n\n    function getFrameSpec() {\n        const spec = {\n            w: 0,\n            h: 0,\n            marginLeft: 0,\n            marginTop: 0\n        };\n        pageList.each(function(i, el) {\n            const size = getSize(el);\n            spec.w += size.width;\n            spec.h += size.height;\n        });\n        if (layoutType === LAYOUT_HORIZONTAL && spec.w < actualViewSize.width) {\n            spec.marginLeft = (actualViewSize.width - spec.w) / 2;\n        } else if (layoutType === LAYOUT_VERTICAL && spec.h < actualViewSize.height) {\n            spec.marginTop = (actualViewSize.height - spec.h) / 2;\n        }\n        return spec;\n    }\n\n    function dragShift(x, y, tr) {\n        if (tr != null) {\n            componentizeStart();\n            componentizeTimeout = setTimeout(function() {\n                componentizeTimeout = null;\n                componentizeStop();\n            }, tr.duration*1000);\n            tr = tr.duration+'s '+tr.easing;\n        } else if (isLazyContainer) {\n            zuix.componentize(cp.view());\n        }\n        pageList.each(function(i, el) {\n            const data = getData(this);\n            transition(this, tr);\n            position(this, data.dragStart.x+x, data.dragStart.y+y);\n        });\n    }\n\n    function dragStop(tp) {\n        if (tp != null) {\n            tp.done = true;\n            // decelerate\n            if (!isFlying && ((layoutType === LAYOUT_HORIZONTAL && tp.scrollIntent() === 'horizontal') || (layoutType === LAYOUT_VERTICAL && tp.scrollIntent() === 'vertical'))) {\n                decelerate(null, tp);\n            }\n        }\n        componentizeStop();\n        isDragging = false;\n    }\n\n    // Gesture handling\n\n    function handlePan(e, tp) {\n        if (!tp.scrollIntent() || tp.done) {\n            return;\n        }\n        if (inputCaptured\n            || ((tp.direction === 'left' || tp.direction === 'right') && layoutType === LAYOUT_HORIZONTAL)\n            || ((tp.direction === 'up' || tp.direction === 'down') && layoutType === LAYOUT_VERTICAL)) {\n            // capture click event\n            if (!inputCaptured && tp.event.touches == null) {\n                cp.view().get().addEventListener('click', function(e) {\n                    if (inputCaptured) {\n                        inputCaptured = false;\n                        e.cancelBubble = true;\n                        // TODO: 'preventDefault' should not be used with passive listeners\n                        e.preventDefault();\n                    }\n                    // release mouse click capture\n                    cp.view().get().removeEventListener('click', this, true);\n                }, true);\n            }\n            inputCaptured = true;\n            tp.cancel();\n        }\n        const spec = getFrameSpec();\n        if (layoutType === LAYOUT_HORIZONTAL && tp.scrollIntent() === 'horizontal') {\n            dragShift(tp.shiftX-spec.marginLeft, 0);\n        } else if (layoutType === LAYOUT_VERTICAL && tp.scrollIntent() === 'vertical') {\n            dragShift(0, tp.shiftY-spec.marginTop);\n        }\n    }\n\n    function handleTap(e, tp) {\n        let vp = cp.view().position();\n        let page = getItemIndexAt(tp.x-vp.x, tp.y-vp.y);\n        cp.trigger('page:tap', page, tp);\n        if (enablePaging) focusPageAt(tp);\n    }\n\n    function decelerate(e, tp) {\n        const minSpeed = 0.01;\n        const minStepSpeed = 1.25;\n        const accelerationFactor = Math.exp(Math.abs(tp.velocity / (Math.abs(tp.velocity) <= minStepSpeed ? 5 : 2))+1);\n        let friction = 0.990 + (accelerationFactor / 1000);\n        if (friction > 0.999) {\n            friction = 0.999;\n        }\n        const duration = Math.log(minSpeed / Math.abs(tp.velocity)) / Math.log(friction);\n        const decelerateEasing = {\n            duration: duration / 1000, // ms to s\n            easing: DECELERATE_SCROLL_EASING\n        };\n        const fly = function(destination, shift) {\n            if (enablePaging) {\n                decelerateEasing.duration *= 0.5;\n                if (layoutType === LAYOUT_HORIZONTAL) {\n                    focusPageAt({\n                        x: destination.x - shift.x,\n                        y: destination.y\n                    }, decelerateEasing);\n                } else {\n                    focusPageAt({\n                        x: destination.x,\n                        y: destination.y - shift.y\n                    }, decelerateEasing);\n                }\n            } else {\n                flyTo(shift, decelerateEasing);\n            }\n        };\n        const flyingDistance = tp.stepSpeed < minStepSpeed ? 0 : accelerationFactor * tp.velocity * (1 - Math.pow(friction, duration + 1)) / (1 - friction);\n        const ap = {\n            x: flyingDistance,\n            y: flyingDistance\n        };\n        if (willFly(tp) || e == null) fly(tp, ap);\n    }\n\n    function willFly(tp) {\n        return (!enablePaging || Math.abs(tp.velocity) > 1.25);\n    }\n\n    function handleSwipe(e, tp) {\n        if (willFly(tp)) {\n            return;\n        }\n        switch (tp.direction) {\n            case 'right':\n                if (layoutType === LAYOUT_HORIZONTAL) prev();\n                break;\n            case 'left':\n                if (layoutType === LAYOUT_HORIZONTAL) next();\n                break;\n            case 'down':\n                if (layoutType === LAYOUT_VERTICAL) prev();\n                break;\n            case 'up':\n                if (layoutType === LAYOUT_VERTICAL) next();\n                break;\n        }\n    }\n\n    function position(el, x, y) {\n        const data = getData(el);\n        if (!isNaN(x) && !isNaN(y)) {\n            data.position = {'x': x, 'y': y};\n            el.css({'left': data.position.x+'px', 'top': data.position.y+'px'});\n        }\n        return data;\n    }\n\n    function transition(el, transition) {\n        if (transition == null) {\n            transition = 'none';\n        }\n        el.css({\n            '-webkit-transition': transition,\n            '-moz-transition': transition,\n            '-ms-transition': transition,\n            '-o-transition': transition,\n            'transition': transition\n        });\n    }\n});\n"
  },
  {
    "componentId": "https://zuixjs.github.io/zkit/lib/controllers/list_view",
    "controller": "/**\n * zUIx - ListView Component\n *\n * @version 1.0.3 (2017-06-11)\n * @author Gene\n *\n */\n\nzuix.controller(function(cp) {\n    // Set list type: [ 'full', 'paged', 'incremental' ] (default: 'full')\n    const MODE_FULL = 'full';\n    const MODE_PAGED = 'paged';\n    const MODE_INCREMENTAL = 'incremental';\n    let listMode = MODE_FULL;\n\n    // How many items per page to show/add (for 'paged' and 'incremental' modes) (default: 30)\n    let itemsPerPage = 30;\n\n    // Structure used to store component state info\n    const statusInfo = {\n        page: {\n            current: 0,\n            count: 0\n        },\n        items: {\n            loaded: 0,\n            count: 0\n        }\n    };\n\n    // Objects data persistence\n    const listItems = [];\n\n    cp.init = function() {\n        cp.options().html = false;\n        cp.options().css = false;\n    };\n\n    // TODO: describe the model and options used by this component\n    cp.create = function() {\n        // exposed methods through this component context\n        cp.expose('config', configure);\n        cp.expose('page', setPage);\n        cp.expose('status', triggerStatus);\n        cp.expose('more', function() {\n            statusInfo.page.current++;\n            cp.update();\n        });\n        cp.expose('clear', clear);\n        // init\n        clear();\n    };\n\n    cp.destroy = function() {\n        clear();\n    };\n\n    cp.update = function() {\n        const modelList = cp.model().itemList;\n        if (modelList == null) return;\n\n        statusInfo.page.count = pageCount();\n        statusInfo.items.count = modelList.length;\n\n        const startItem = statusInfo.page.current*itemsPerPage;\n        let i = 0;\n        if (listMode === MODE_PAGED && startItem > 0) {\n            i = startItem;\n        }\n\n        for ( ; i < modelList.length; i++) {\n            const dataItem = cp.model().getItem(i, modelList[i]);\n            const id = dataItem.itemId;\n\n            if ((listMode === MODE_FULL) ||\n                (listMode === MODE_PAGED && i >= startItem && i < startItem+itemsPerPage) ||\n                (listMode === MODE_INCREMENTAL && i < startItem+itemsPerPage)) {\n                if (typeof listItems[id] === 'undefined') {\n                    const container = zuix.createComponent(dataItem.componentId, dataItem.options).container();\n                    // use a responsive CSS class if provided\n                    if (dataItem.options.className != null) {\n                        // this class should set the min-height property\n                        container.classList.add(dataItem.options.className);\n                    } else {\n                        // set a temporary height for the container (for lazy load to work properly)\n                        container.style['min-height'] = dataItem.options.height || '48px';\n                    }\n                    // register a callback to know when the component is actually loaded\n                    const listener = function(itemIndex, el) {\n                        const l = function() {\n                            el.removeEventListener('component:ready', l);\n                            // trigger status update event\n                            statusInfo.items.loaded++;\n                            triggerStatus();\n                            // if all components have been loaded, then trigger 'complete' event\n                            if (itemIndex === modelList.length - 1) {\n                                cp.trigger('complete');\n                            }\n                        };\n                        container.addEventListener('component:ready', l);\n                    }(i, container);\n                    // keep track of already allocated items\n                    listItems[id] = container;\n                    // add item container to the list-view, the component will be lazy-loaded later as needed\n                    cp.view().insert(i-startItem, listItems[id]);\n                } else if (!dataItem.options.static) {\n                    // update existing item model's data\n                    // TODO: should check if the data in the model has changed before calling this\n                    // TODO: should also call the `model` method in the `zuix.context` callback\n                    zuix.context(listItems[id]).model(dataItem.options.model);\n                }\n            }\n\n            if (typeof listItems[id] !== 'undefined') {\n                if ((listMode === MODE_PAGED && i < statusInfo.page.current * itemsPerPage)\n                    || (listMode !== MODE_FULL && i > ((statusInfo.page.current + 1) * itemsPerPage - 1))) {\n                    listItems[id].style['display'] = 'none';\n                } else {\n                    listItems[id].style['display'] = '';\n                }\n            }\n\n            if ((listMode === MODE_PAGED || listMode === MODE_INCREMENTAL) && i > startItem+itemsPerPage) {\n                break;\n            }\n        }\n\n        // trigger status update event\n        triggerStatus();\n\n        // `componentize` is required to process lazy-loaded items\n        zuix.componentize(cp.view());\n    };\n\n    function setPage(number) {\n        if (!isNaN(number) && number >= 0 && number < pageCount()) {\n            if (listMode == MODE_PAGED) {\n                clearPage(statusInfo.page.current);\n            }\n            statusInfo.page.current = parseInt(number);\n            cp.update();\n        }\n        return statusInfo.page.current;\n    }\n\n    function clearPage(number) {\n        const modelList = cp.model().itemList;\n        if (modelList == null) return;\n        const startItem = number*itemsPerPage;\n        for (let i = startItem; i < listItems.length && i < startItem+itemsPerPage; i++) {\n            const dataItem = cp.model().getItem(i, modelList[i]);\n            const id = dataItem.itemId;\n            if (typeof listItems[id] !== 'undefined') {\n                listItems[id].style['display'] = 'none';\n            }\n        }\n    }\n\n    function triggerStatus() {\n        cp.trigger('status', statusInfo);\n    }\n\n    function pageCount() {\n        return Math.ceil(cp.model().itemList.length / itemsPerPage);\n    }\n\n    function configure(options) {\n        if (options.itemsPerPage != null) {\n            itemsPerPage = options.itemsPerPage;\n        }\n        if (options.listMode != null) {\n            listMode = options.listMode;\n        }\n    }\n\n    function clear() {\n        // dispose components\n        for (let i = 0; i < listItems.length; i++) {\n            zuix.unload(listItems[i]);\n        }\n        listItems.length = 0;\n        statusInfo.page.current = 0;\n        statusInfo.page.count = 0;\n        statusInfo.items.loaded = 0;\n        statusInfo.items.count = 0;\n        // clear the view\n        cp.view().html('');\n    }\n});\n"
  }
])</script>
</body></html>