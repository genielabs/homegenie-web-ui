<div data-ui-field="toolbox" layout="column top-stretch" class="toolbox mdl-shadow--24dp">

    <div class="header mdl-shadow--6dp" layout="row center-justify">
        <div class="logo">
            <span>z</span><strong>UI</strong><span>x</span>
            hack box
        </div>
        <div self="right">
            <a data-ui-field="button-fullscreen" class="mdl-button mdl-js-button mdl-js-ripple-effect">
                <i class="material-icons">fullscreen</i>
            </a>
        </div>
    </div>

    <div self="size-x1" data-ui-load="controllers/paged_view" data-ui-field="paged-view" data-ui-context="pagedView" data-ui-relative="true" layout="column stretch-stretch">

        <div data-ui-field="fragmemnt-components" data-ui-load="tools/zuix_editor" data-ui-context="zuix-editor" data-ui-lazyload="scroll" class="bundle-box mdl-color--white mdl-color-text--black scrollable content-padding" layout="row stretch-stretch">
        </div>
        <div data-ui-field="fragment-log" data-ui-lazyload="scroll" class="log-box scrollable mdl-shadow--16dp" layout="column top-stretch">

            <div data-ui-field="log-list" data-ui-lazyload="false" data-ui-load="@lib/controllers/list_view" self="size-x1">

                loading...

            </div>
        </div>
        <div data-ui-field="fragment-bundle" data-ui-lazyload="scroll" class="bundle-box  mdl-color--white mdl-color-text--black scrollable content-padding">

            <div class="content-padding" layout="columns spread">
                <p>
                    When a zuix-based web site or app is ready for production, it can be bundled into
                    a single file containing all components and assets.
                </p>
                <div data-ui-field="bundle-progress" class="content-padding" align="center">
                    <div self="size-1of3" class="mdl-progress mdl-js-progress mdl-progress__indeterminate"></div>
                </div>
                <div align="center" layout="row top-spread">
                    <div class="content-padding">
                        <a data-ui-field="button-load" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--raised mdl-color-text--accent">Load all components</a>
                    </div>
                    <div class="content-padding">
                        <a data-ui-field="button-save" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--raised mdl-color-text--accent">Download Bundle</a>
                    </div>
                </div>
                <br>
                <small>
                    The generated bundle can be partial, containing only components created until
                    the bundle request, or it can be complete when the app does not use
                    lazy-loading or by forcing loading of all components before downloading
                    the bundle.
                    <br>
                    Include the generated file right after the <u>zuix.min.js</u> script.
                    Using a single app bundle will speed up loading when ready for production.
                </small>
            </div>

        </div>

    </div>
    <div class="footer mdl-shadow--24dp" layout="row center-spread">
        <a data-ui-field="button-components" class="material-icons mdl-color-text--blue-900 mdl-badge mdl-badge--overlap margin-left" data-badge="!">
            extension
        </a>
        <a data-ui-field="button-log" class="mdl-button mdl-js-button margin-left alert">Log</a>
        <a data-ui-field="button-bundle" class="mdl-button mdl-js-button margin-left">Bundle</a>
        <div self="size-x1" layout="row center-center">
            <small data-ui-field="editor-info" class="mdl-color-text--accent"></small>
        </div>
        <a data-ui-field="button-hide" class="mdl-button mdl-button--icon mdl-js-button mdl-js-ripple-effect">
            <i class="material-icons">close</i>
        </a>
    </div>
</div>

<div data-ui-field="log-overlay" class="log-overlay">

</div>

<div data-ui-field="fab-menu" class="fab-menu alert">
    <a data-ui-field="components" class="mdl-button mdl-js-button mdl-button--fab mdl-button--mini-fab mdl-color--yellow-A400 mdl-js-ripple-effect mdl-shadow--24dp mdl-badge mdl-badge--overlap" data-badge="!">
        <i class="material-icons mdl-color-text--blue-900">extension</i>
    </a>
</div>
<!-- zUIx inline resource resourceBundle -->
<!--{[tools/zuix_editor]}-->
<div data-ui-view="tools/zuix_editor">
<div data-ui-field="fragment-list" class="list-box">

    <div class="heading" layout="row center-spread">
        <div self="left">
            <h6>Components</h6>
        </div>
        <div self="spread right" align="right"><small>loaded<br>instances</small></div>
    </div>

    <div data-ui-field="component-list" data-ui-lazyload="false" data-ui-load="@lib/controllers/list_view">

        loading...

    </div>

    <div layout="row center-justify" class="summary">
        <div self="left">
            <small>loaded <span data-ui-field="total-components">--</span> components</small>
        </div>
        <div layout="row center-right">
            <small>total instances <span data-ui-field="total-instances">--</span></small>
        </div>
    </div>

</div>

<div data-ui-field="fragment-editor" class="editor-box mdl-color-text--lime-400" layout="row stretch-stretch">

    <div class="mdl-tabs mdl-js-tabs mdl-js-ripple-effect mdl-color--white" layout="column top-stretch">
        <div class="mdl-tabs__tab-bar">
            <a href="#hackbox-editor-js" class="mdl-tabs__tab is-active">JavaScript</a>
            <a href="#hackbox-editor-html" class="mdl-tabs__tab">HTML</a>
            <a href="#hackbox-editor-css" class="mdl-tabs__tab">CSS</a>
        </div>
        <pre id="hackbox-editor-js" self="size-x1" class="mdl-tabs__panel scrollable-relative is-active"><code data-ui-field="js" class="language-javascript"></code></pre>
        <pre id="hackbox-editor-html" self="size-x1" class="mdl-tabs__panel scrollable-relative"><code data-ui-field="html" class="language-html"></code></pre>
        <pre id="hackbox-editor-css" self="size-x1" class="mdl-tabs__panel scrollable-relative"><code data-ui-field="css" class="language-css"></code></pre>
    </div>

</div>

</div>
<script>zuix.bundle([
  {
    "componentId": "controllers/paged_view",
    "controller": "\"use strict\";\nzuix.controller(function (cp) {\n    let currentPage = -1;\n\n    cp.init = function () {\n        cp.options().html = false;\n        cp.options().css = false;\n    };\n\n    cp.create = function () {\n        cp.expose('setPage', setPage);\n        cp.expose('getPage', getPage);\n        cp.expose('getCurrent', getCurrent);\n        cp.expose('getCurrentPage', getCurrentPage);\n        cp.view().children().each(function (i, el) {\n            if (cp.view().attr('data-ui-relative') != 'true') {\n                el.style['position'] = 'absolute';\n                el.style['top'] = '0';\n                el.style['left'] = '0';\n                el.style['bottom'] = '0';\n                el.style['right'] = '0';\n                el.style['overflow'] = 'auto';\n                el.style['overflow-x'] = 'hidden';\n                el.style['-webkit-overflow-scrolling'] = 'touch';\n            }\n            this.hide();\n        });\n        setPage(0);\n    };\n\n    cp.destroy = function () {\n        cp.view().children().each(function () {\n            // TODO: should restore original container styles\n        });\n        currentPage = -1;\n    };\n\n    // Private Members\n\n    function getPage(p) {\n        const pages = cp.view().children();\n        return pages.eq(p);\n    }\n\n    function getCurrentPage() {\n        return getPage(currentPage);\n    }\n\n    function getCurrent() {\n        return currentPage;\n    }\n\n    function setPage(p, anchor) {\n        const pages = cp.view().children();\n        const oldPage = currentPage;\n        if (p != currentPage) {\n            currentPage = p;\n            pages.eq(p).show();\n            zuix.componentize();\n            if (oldPage != -1) {\n                pages.eq(oldPage).hide();\n                cp.trigger('page:change', {\n                    old: oldPage,\n                    page: currentPage\n                });\n            }\n        }\n        if (!isNaN(anchor))\n            pages.get(p).scrollTop = anchor;\n        else if (anchor != null)\n            pages.get(p).scrollTop = pages.eq(p)\n                .find('a[id='+anchor+']')\n                .position().y;\n    }\n\n});\n"
  },
  {
    "componentId": "tools/zuix_editor",
    "controller": "zuix.controller(function (cp) {\n    /** @type {ComponentContext} */\n    var componentListView = null;\n    /** @type {ZxQuery} */\n    var editorFragment = null,\n        /** @type {ZxQuery} */\n        componentListFragment = null,\n        /** @type {ComponentContext} (bundle_item) */\n        currentItem;\n\n    cp.create = function () {\n        editorFragment = cp.field('fragment-editor');\n        componentListFragment = cp.field('fragment-list');\n        cp.field('component-list').on('component:ready', function () {\n            componentListView = zuix.context(this);\n            componentListView.config({\n                htmlMode: false\n            });\n            update();\n            showComponents();\n        });\n        cp.expose({\n            update: update,\n            show: showComponents,\n            serialize: serialize\n        });\n    };\n\n    // private members\n\n    function update() {\n        if (componentListView == null) return;\n        var instancesCount = 0;\n        var bundle = zuix.bundle().slice(0);\n        bundle.sort(function (a, b) {\n            return (a.componentId.toString() < b.componentId.toString())\n                ? -1 : (a.componentId.toString() > b.componentId.toString())\n                    ? 1 : 0;\n        });\n        componentListView.model({\n            itemList: bundle,\n            getItem: function (index, item) {\n                item.index = index;\n                return {\n                    // unique identifier for this item\n                    itemId: item.componentId,\n                    // display as \"bundle item\"\n                    componentId: 'tools/zuix_editor/bundle_item',\n                    // loading options\n                    options: {\n                        model: item,\n                        lazyLoad: true,\n                        height: '56px',\n                        on: {\n                            'item:click': openEditor,\n                            'item:update': function () {\n                                var ctx = zuix.context(this);\n                                // do not count if is zuix-hackbox\n                                if (ctx.instanceCount != null && (ctx.isHackBox == null || !ctx.isHackBox()))\n                                    instancesCount += ctx.instanceCount();\n                                if (index == bundle.length - 1) {\n                                    cp.field('total-components').html(zuix.bundle().length);\n                                    cp.field('total-instances').html(instancesCount);\n                                }\n                            }\n                        },\n                        ready: function () {\n                        }\n                    }\n                }\n            }\n        });\n    }\n\n    function showComponents() {\n        closeEditor();\n        cp.trigger('page:change', {\n            page: 'list'\n        });\n    }\n\n    function openEditor(e, item) {\n        // get the item component context\n        var ctx = zuix.context(this);\n        currentItem = ctx;\n        var tabs = cp.view('.mdl-tabs__tab,.mdl-tabs__panel')\n            .hide();\n        if (ctx.hasResource('css')) {\n            tabs.removeClass('is-active')\n                .eq(2, 5).show().addClass('is-active');\n            cp.field('css').html(item.css);\n            //Prism.highlightElement(cp.field('css').get());\n        }\n        if (ctx.hasResource('html')) {\n            tabs.removeClass('is-active')\n                .eq(1, 4).show().addClass('is-active');\n            var html = item.view\n                .replace(/\\</g, \"&lt;\")\n                .replace(/\\>/g, \"&gt;\")\n                .replace(/ zuix-loaded=\"true\"/g, '');\n            cp.field('html').html(html);\n            //Prism.highlightElement(cp.field('html').get());\n        }\n        if (ctx.hasResource('js')) {\n            tabs.removeClass('is-active')\n                .eq(0, 3).show().addClass('is-active');\n            cp.field('js').html(serialize(item.controller));\n            //Prism.highlightElement(cp.field('js').get());\n        }\n        editorFragment.animateCss('slideInRight', { duration: '0.2s' }).show();\n        componentListFragment.animateCss('slideOutLeft', { duration: '0.2s' }, function () {\n            this.hide();\n        });\n        cp.trigger('page:change', {\n            page: 'editor',\n            context: ctx\n        });\n    }\n\n    function closeEditor() {\n        if (currentItem != null) {\n            componentListFragment.show().animateCss('slideInLeft', { duration: '0.2s' });\n            editorFragment.animateCss('slideOutRight', { duration: '0.2s' }, function () {\n                this.hide();\n            });\n            currentItem = null;\n            cp.trigger('page:change', {\n                page: 'list'\n            });\n        } else {\n            componentListFragment.show();\n            editorFragment.hide();\n        }\n    }\n\n    // component item serialization\n\n    var isRegExp = function (re) {\n        return Object.prototype.toString.call(re) === '[object RegExp]';\n    };\n\n    // FileSaver polyfill:\n    //      https://github.com/eligrey/FileSaver.js/blob/master/FileSaver.min.js\n    // Generate an internal UID to make the regexp pattern harder to guess.\n\n    var UID                 = Math.floor(Math.random() * 0x10000000000).toString(16);\n    var PLACE_HOLDER_REGEXP = new RegExp('\"@__(F|R)-' + UID + '-(\\\\d+)__@\"', 'g');\n\n    var IS_NATIVE_CODE_REGEXP = /\\{\\s*\\[native code\\]\\s*\\}/g;\n    var UNSAFE_CHARS_REGEXP   = /[<>\\/\\u2028\\u2029]/g;\n\n    // Mapping of unsafe HTML and invalid JavaScript line terminator chars to their\n    // Unicode char counterparts which are safe to use in JavaScript strings.\n    var ESCAPED_CHARS = {\n        '<'     : '\\\\u003C',\n        '>'     : '\\\\u003E',\n        '/'     : '\\\\u002F',\n        '\\u2028': '\\\\u2028',\n        '\\u2029': '\\\\u2029'\n    };\n\n    function escapeUnsafeChars(unsafeChar) {\n        return ESCAPED_CHARS[unsafeChar];\n    }\n\n    var serialize = function(obj, options) {\n        options || (options = {});\n\n        // Backwards-compatability for `space` as the second argument.\n        if (typeof options === 'number' || typeof options === 'string') {\n            options = {space: options};\n        }\n\n        var functions = [];\n        var regexps = [];\n\n        // Returns placeholders for functions and regexps (identified by index)\n        // which are later replaced by their string representation.\n        function replacer(key, value) {\n            if (!value) {\n                return value;\n            }\n\n            var type = typeof value;\n\n            if (type === 'object') {\n                if (isRegExp(value)) {\n                    return '@__R-' + UID + '-' + (regexps.push(value) - 1) + '__@';\n                }\n\n                return value;\n            }\n\n            if (type === 'function') {\n                return '@__F-' + UID + '-' + (functions.push(value) - 1) + '__@';\n            }\n\n            return value;\n        }\n\n        var str;\n\n        // Creates a JSON string representation of the value.\n        // NOTE: Node 0.12 goes into slow mode with extra JSON.stringify() args.\n        if (options.isJSON && !options.space) {\n            str = JSON.stringify(obj);\n        } else {\n            str = JSON.stringify(obj, options.isJSON ? null : replacer, options.space);\n        }\n\n        // Protects against `JSON.stringify()` returning `undefined`, by serializing\n        // to the literal string: \"undefined\".\n        if (typeof str !== 'string') {\n            return String(str);\n        }\n\n        // Replace unsafe HTML and invalid JavaScript line terminator chars with\n        // their safe Unicode char counterpart. This _must_ happen before the\n        // regexps and functions are serialized and added back to the string.\n        str = str.replace(UNSAFE_CHARS_REGEXP, escapeUnsafeChars);\n\n        if (functions.length === 0 && regexps.length === 0) {\n            return str;\n        }\n\n        // Replaces all occurrences of function and regexp placeholders in the JSON\n        // string with their string representations. If the original value can not\n        // be found, then `undefined` is used.\n        return str.replace(PLACE_HOLDER_REGEXP, function (match, type, valueIndex) {\n            if (type === 'R') {\n                return regexps[valueIndex].toString();\n            }\n\n            var fn = functions[valueIndex];\n            var serializedFn = fn.toString();\n\n            if (IS_NATIVE_CODE_REGEXP.test(serializedFn)) {\n                throw new TypeError('Serializing native function: ' + fn.name);\n            }\n\n            return serializedFn;\n        });\n    };\n\n});\n",
    "css": "h6 {\n    padding-top:0;\n    font-weight: 700;\n}\n.list-box {\n    position: absolute;\n    top:0;left:0;right:0;bottom:0;\n}\n.editor-box {\n    position: absolute;\n    top:0;left:0;right:0;bottom:0;\n    padding: 2px;\n}\n.editor-box .mdl-tabs {\n    position: absolute;top: 0;bottom: 0;left: 0;right: 0;\n}\n.scrollable-relative {\n    border: 1px solid;\n    margin: 2px;\n}\n.heading {\n    padding-left:24px;\n    padding-right:8px;\n    color: grey;\n    font-weight:500;\n}\n.summary {\n    display: none;\n    margin-bottom: 48px;\n    padding: 16px;\n    background-color: rgba(0,255,0,0.1);\n}\n.summary span {\n    font-weight: 700;\n}\n.editor-header {\n    z-index: 10;\n}"
  },
  {
    "componentId": "https://zuixjs.github.io/zkit/lib/controllers/list_view",
    "controller": "/**\n * zUIx - ListView Component\n *\n * @version 1.0.3 (2017-06-11)\n * @author Gene\n *\n */\n\nzuix.controller(function(cp) {\n    // Set list type: [ 'full', 'paged', 'incremental' ] (default: 'full')\n    const MODE_FULL = 'full';\n    const MODE_PAGED = 'paged';\n    const MODE_INCREMENTAL = 'incremental';\n    let listMode = MODE_FULL;\n\n    // How many items per page to show/add (for 'paged' and 'incremental' modes) (default: 30)\n    let itemsPerPage = 30;\n\n    // Structure used to store component state info\n    const statusInfo = {\n        page: {\n            current: 0,\n            count: 0\n        },\n        items: {\n            loaded: 0,\n            count: 0\n        }\n    };\n\n    // Objects data persistence\n    const listItems = [];\n\n    cp.init = function() {\n        cp.options().html = false;\n        cp.options().css = false;\n    };\n\n    // TODO: describe the model and options used by this component\n    cp.create = function() {\n        // exposed methods through this component context\n        cp.expose('config', configure);\n        cp.expose('page', setPage);\n        cp.expose('status', triggerStatus);\n        cp.expose('more', function() {\n            statusInfo.page.current++;\n            cp.update();\n        });\n        cp.expose('clear', clear);\n        // init\n        clear();\n    };\n\n    cp.destroy = function() {\n        clear();\n    };\n\n    cp.update = function() {\n        const modelList = cp.model().itemList;\n        if (modelList == null) return;\n\n        statusInfo.page.count = pageCount();\n        statusInfo.items.count = modelList.length;\n\n        const startItem = statusInfo.page.current*itemsPerPage;\n        let i = 0;\n        if (listMode === MODE_PAGED && startItem > 0) {\n            i = startItem;\n        }\n\n        for ( ; i < modelList.length; i++) {\n            const dataItem = cp.model().getItem(i, modelList[i]);\n            const id = dataItem.itemId;\n\n            if ((listMode === MODE_FULL) ||\n                (listMode === MODE_PAGED && i >= startItem && i < startItem+itemsPerPage) ||\n                (listMode === MODE_INCREMENTAL && i < startItem+itemsPerPage)) {\n                if (typeof listItems[id] === 'undefined') {\n                    const container = zuix.createComponent(dataItem.componentId, dataItem.options).container();\n                    // use a responsive CSS class if provided\n                    if (dataItem.options.className != null) {\n                        // this class should set the min-height property\n                        container.classList.add(dataItem.options.className);\n                    } else {\n                        // set a temporary height for the container (for lazy load to work properly)\n                        container.style['min-height'] = dataItem.options.height || '48px';\n                    }\n                    // register a callback to know when the component is actually loaded\n                    const listener = function(itemIndex, el) {\n                        const l = function() {\n                            el.removeEventListener('component:ready', l);\n                            // trigger status update event\n                            statusInfo.items.loaded++;\n                            triggerStatus();\n                            // if all components have been loaded, then trigger 'complete' event\n                            if (itemIndex === modelList.length - 1) {\n                                cp.trigger('complete');\n                            }\n                        };\n                        container.addEventListener('component:ready', l);\n                    }(i, container);\n                    // keep track of already allocated items\n                    listItems[id] = container;\n                    // add item container to the list-view, the component will be lazy-loaded later as needed\n                    cp.view().insert(i-startItem, listItems[id]);\n                } else if (!dataItem.options.static) {\n                    // update existing item model's data\n                    // TODO: should check if the data in the model has changed before calling this\n                    // TODO: should also call the `model` method in the `zuix.context` callback\n                    zuix.context(listItems[id]).model(dataItem.options.model);\n                }\n            }\n\n            if (typeof listItems[id] !== 'undefined') {\n                if ((listMode === MODE_PAGED && i < statusInfo.page.current * itemsPerPage)\n                    || (listMode !== MODE_FULL && i > ((statusInfo.page.current + 1) * itemsPerPage - 1))) {\n                    listItems[id].style['display'] = 'none';\n                } else {\n                    listItems[id].style['display'] = '';\n                }\n            }\n\n            if ((listMode === MODE_PAGED || listMode === MODE_INCREMENTAL) && i > startItem+itemsPerPage) {\n                break;\n            }\n        }\n\n        // trigger status update event\n        triggerStatus();\n\n        // `componentize` is required to process lazy-loaded items\n        zuix.componentize(cp.view());\n    };\n\n    function setPage(number) {\n        if (!isNaN(number) && number >= 0 && number < pageCount()) {\n            if (listMode == MODE_PAGED) {\n                clearPage(statusInfo.page.current);\n            }\n            statusInfo.page.current = parseInt(number);\n            cp.update();\n        }\n        return statusInfo.page.current;\n    }\n\n    function clearPage(number) {\n        const modelList = cp.model().itemList;\n        if (modelList == null) return;\n        const startItem = number*itemsPerPage;\n        for (let i = startItem; i < listItems.length && i < startItem+itemsPerPage; i++) {\n            const dataItem = cp.model().getItem(i, modelList[i]);\n            const id = dataItem.itemId;\n            if (typeof listItems[id] !== 'undefined') {\n                listItems[id].style['display'] = 'none';\n            }\n        }\n    }\n\n    function triggerStatus() {\n        cp.trigger('status', statusInfo);\n    }\n\n    function pageCount() {\n        return Math.ceil(cp.model().itemList.length / itemsPerPage);\n    }\n\n    function configure(options) {\n        if (options.itemsPerPage != null) {\n            itemsPerPage = options.itemsPerPage;\n        }\n        if (options.listMode != null) {\n            listMode = options.listMode;\n        }\n    }\n\n    function clear() {\n        // dispose components\n        for (let i = 0; i < listItems.length; i++) {\n            zuix.unload(listItems[i]);\n        }\n        listItems.length = 0;\n        statusInfo.page.current = 0;\n        statusInfo.page.count = 0;\n        statusInfo.items.loaded = 0;\n        statusInfo.items.count = 0;\n        // clear the view\n        cp.view().html('');\n    }\n});\n"
  }
])</script>
